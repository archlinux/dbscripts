#!/bin/bash

. "$(dirname "$(readlink -e "$0")")/config"
. "$(dirname "$(readlink -e "$0")")/db-functions"

if (( $# >= 1 )); then
	warning "Calling %s with a specific repository is no longer supported" "${0##*/}"
	exit 1
fi

# Find repos with packages to release
mapfile -t -d '' staging_repos < <(
	for f in "${STAGING}"/**/*${PKGEXTS}; do
		printf '%s\0' "${f%/*}"
	done | sort -uz
)

repos=()
for staging_repo in "${staging_repos[@]##*/}"; do
	if in_array "${staging_repo}" "${PKGREPOS[@]}"; then
		repos+=("${staging_repo}")
	fi
done

# TODO: this might lock too much (architectures)
for repo in "${repos[@]}"; do
	for pkgarch in "${ARCHES[@]}"; do
		repo_lock "${repo}" "${pkgarch}" || exit 1
	done
done


for repo in "${repos[@]}"; do
	if pkgs=($(getpkgfiles "${STAGING}/${repo}/"*${PKGEXTS})); then
		for pkg in "${pkgs[@]}"; do
			if ! fetch_pkgbuild "$(getpkgbase "${pkg}")"; then
				die "Couldn't find package %s in git!" "${pkg}"
			fi
		done
	fi
done


if ! check_author; then
	die "You don't have a matching author mapping"
fi

# check if packages are valid
for repo in "${repos[@]}"; do
	if ! check_repo_permission "${repo}"; then
		die "You don't have permission to update packages in %s" "$repo"
	fi
	if pkgs=($(getpkgfiles "${STAGING}/${repo}/"*${PKGEXTS})); then
		for pkg in "${pkgs[@]}"; do
			if [[ -h ${pkg} ]]; then
				die "Package %s is a symbolic link" "$repo/${pkg##*/}"
			fi
			if ! check_signed_tag "${pkg}"; then
				die "Package %s does not have a signed tag matching the version" "$repo/${pkg##*/}"
			fi
			if ! check_pkgbuild_checksum "${pkg}"; then
				die "Package %s was not built with the checked in PKGBUILD" "$repo/${pkg##*/}"
			fi
			if ! check_pkgfile "${pkg}"; then
				die "Package %s is not consistent with its meta data" "$repo/${pkg##*/}"
			fi
			if ! pacman-key --verify "${pkg}.sig" "${pkg}" >/dev/null 2>&1; then
				die "Package %s does not have a valid signature" "$repo/${pkg##*/}"
			fi
			if ! check_pkgvcs "${pkg}" "${repo}"; then
				die "Package %s is not consistent with %s repository" "$repo/${pkg##*/}" "${VCS}"
			fi
			if ! check_pkgrepos "${pkg}"; then
				die "Package %s already exists in another repository" "$repo/${pkg##*/}"
			fi
			if ! missing_repo="$(check_stagingrepos "${pkg}" "${repo}")"; then
				die "Package %s in %s needs to be updated in unstable repos as well: %s" "${pkg}" "${repo}" "${missing_repo}"
			fi
			if ! check_packager "${pkg}"; then
				die "Package %s does not have a valid packager" "$repo/${pkg##*/}"
			fi
			if ! check_buildinfo "${pkg}"; then
				die "Package %s does not have a .BUILDINFO file" "$repo/${pkg##*/}"
			fi
			if ! check_builddir "${pkg}"; then
				die "Package %s was not built in a chroot" "$repo/${pkg##*/}"
			fi
			if ! check_reproducible "${pkg}"; then
				error "Package %s is not reproducible." "${pkg}"
				die "Ensure that all dependencies are available in the repositories or are added in the same db-update."
			fi
		done
		if ! check_splitpkgs "${repo}" "${pkgs[@]}"; then
			die "Missing split packages for %s" "$repo"
		fi
		# TODO:
		# Add history repo information check as detailed in proposal
	else
		die "Could not read %s" "$STAGING"
	fi
done

for repo in "${repos[@]}"; do
	msg "Updating [%s]..." "$repo"
	declare -A add_vcspkgs
	any_pkgs=($(getpkgfiles "${STAGING}/${repo}/"*-any${PKGEXTS} 2>/dev/null))
	for pkgarch in "${ARCHES[@]}"; do
		add_pkgs=()
		debug_pkgs=()
		arch_pkgs=($(getpkgfiles "${STAGING}/${repo}/"*"-${pkgarch}"${PKGEXTS} 2>/dev/null))
		for pkg in "${arch_pkgs[@]}" "${any_pkgs[@]}"; do
			pkgfile="${pkg##*/}"
			if [[ ! "${add_vcspkgs["${pkgfile}::pkgbase"]+exists}" ]]; then
				if ! pkgbase="$(getpkgbase "${pkg}")" || \
						! pkgver="$(getpkgver "${pkg}")"; then
					die "Failed to get metadata from '%s'" "${pkg}"
				fi
				add_vcspkgs["${pkgfile}::pkgbase"]="${pkgbase}"
				add_vcspkgs["${pkgfile}::pkgver"]="${pkgver}"

				is_debug_package "${pkg}"
				add_vcspkgs["${pkgfile}::debug"]=$(( $? == 0 ))
			fi

			if (( ${add_vcspkgs["${pkgfile}::debug"]} )); then
				debug_pkgs+=("${pkgfile}")
				currentpool=${PKGPOOL}-debug
				currentrepo=${repo}-debug
			else
				add_pkgs+=("${pkgfile}")
				currentpool=${PKGPOOL}
				currentrepo=${repo}
			fi

			msg2 '%s (%s)' "$pkgfile" "$pkgarch"
			# any packages might have been moved by the previous run
			if [[ -f ${pkg} ]]; then
				mv "${pkg}" "$FTP_BASE/${currentpool}"
			fi
			mkdir -p "$FTP_BASE/${currentrepo}/os/${pkgarch}"
			ln -sf "../../../${currentpool}/${pkgfile}" "$FTP_BASE/${currentrepo}/os/${pkgarch}"
			# also move signatures
			if [[ -f ${pkg}.sig ]]; then
				mv "${pkg}.sig" "$FTP_BASE/${currentpool}"
			fi
			if [[ ${PKGPOOL} = "${currentpool}" ]]; then
				# do not archive debug info, this is not of historic interest
				"$(dirname "$(readlink -e "${BASH_SOURCE[0]}")")/db-archive" "${FTP_BASE}/${PKGPOOL}/${pkg##*/}"
			fi
			if [[ -f $FTP_BASE/${currentpool}/${pkgfile}.sig ]]; then
				ln -sf "../../../${currentpool}/${pkgfile}.sig" "$FTP_BASE/${currentrepo}/os/${pkgarch}"
			fi
		done
		if (( ${#add_pkgs[@]} >= 1 )); then
			arch_repo_modify add "${repo}" "${pkgarch}" "${add_pkgs[@]}"
		fi
		if (( ${#debug_pkgs[@]} >= 1 )); then
			arch_repo_modify add "${repo}-debug" "${pkgarch}" "${debug_pkgs[@]}"
		fi
		if ((REPO_MODIFIED)); then
			for pkg in "${add_pkgs[@]}"; do
				if [[ $pkg == *-any${PKGEXTS} ]]; then
					pkgarch=any
				fi
				pkgbase="${add_vcspkgs[$pkg::pkgbase]}"
				pkgver="${add_vcspkgs[$pkg::pkgver]}"
				vcs_update_package "${pkgbase}" "${pkgver}" "${repo}-${pkgarch}"
			done
		fi
	done
done

for repo in "${repos[@]}"; do
	for pkgarch in "${ARCHES[@]}"; do
		repo_unlock "${repo}" "${pkgarch}"
	done
done
